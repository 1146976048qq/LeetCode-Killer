# 华为车 BU 面试题
# ***************************************
# 200. 岛屿数量
# ***************************************
# 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格， 请计算岛屿的数量。 一个岛被水包围， 并且它是通过水和岛屿连接而成的。 你可以假设网格的四个边均被水包围。
# ***************************************
# 示例 1:
# 输入:
# 11110
# 11010
# 11000
# 00000
# 输出: 1
# 示例 2:
# 输入:
# 11000
# 11000
# 00100
# 00011
# 输出: 3
# 解释: 因为岛屿包含下列三个点:
# {0, 0}, {0, 1}, {1, 2}
# ***************************************
# 思路：
# 1. 深度优先搜索
# 2. 利用集合来记录已经访问过的点
# 3. 如果当前点的上下左右四个点都是陆地，则说明当前点是一个岛屿，岛屿数量加一
# 4. 如果当前点的上下左右四个点都是水，则说明当前点是一个水域，不做任何处理
# ***************************************
# https://leetcode.cn/problems/number-of-islands/
#

class Solution():
    def numIslands(self, grid):
        if not grid: # 如果网格为空，则返回0
            return 0
        count = 0
        for i in range(len(grid)): # 遍历网格
            for j in range(len(grid[0])): # 遍历每一行
                if grid[i][j] == '1': # 如果当前点是陆地，则记录岛屿数量
                    self.dfs(grid, i, j) # 调用dfs函数
                    count += 1 # 岛屿数量加一
        return count # 返回岛屿数量

    def dfs(self, grid, i, j): # 深度优先搜索
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1': # 如果当前点不是陆地，则不做任何处理
            return  # 结束函数
        grid[i][j] = '#' # 将当前点设置为水域
        self.dfs(grid, i+1, j) # 向下搜索
        self.dfs(grid, i-1, j) # 向上搜索
        self.dfs(grid, i, j+1) # 向右搜索
        self.dfs(grid, i, j-1) # 向左搜索

# 示例1
grid1 = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
]

# 示例2
grid2 = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
]

print(Solution().numIslands(grid1))
print(Solution().numIslands(grid2))
